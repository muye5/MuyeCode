// Copyright (c) 2013
// Author: Muye (muyepiaozhou@gmail.com)
// 曹鹏的代码:牛啊~~
//
// 优化一
// 对于01背包的动态规划问题来讲,如果不要求最后背包一定要装满,那么可以初始化f[0...V] = 0
// 但是如果要求最终结果一定要把背包装满,则在初始化时,必须将f[0] = 0而f[1...V] = INT_MIN
// 因为此时代表0个物品在容量为V的情况下符合要求的状态,显然这样的状态时不存在的,故必须为负无穷
// 这时在每次循环时,f数组中只有当v可以等于几个物品体积之和时才会有值,其余情况均为负无穷
//
// 优化二
// 其实在第二层循环处,也就是从最大背包容量W降到c[i]的循环时,其实c[i]未必是最优的下界
// 因为对于背包问题的推导公式而言,f[i][w] = f[i-1][w-c[i]] + p[i]时,w-c[i]未必比c[i]要小
// 而我们只需要知道在容量等于w-c[i]时的最优解就可以判断出对于新添加的物品i,f[i][w]的最优解
// 所以第二层循环的上界应该是max(W-sum{c[j]|i<=j<=n}, c[i])
#include<stdio.h>

int a[10005];
int main() {
    int n,w,c,v,i,j;
    scanf("%d%d",&n,&w);
    for(i=0;i<n;i++) {
        scanf("%d%d",&v,&c);
        for(j=w;j>=v;j--)
            a[j]=a[j]>a[j-v]+c?a[j]:a[j-v]+c;
    }
    printf("%d\n",a[w]);
}

